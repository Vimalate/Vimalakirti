{"./":{"url":"./","title":"首页","keywords":"","body":"Introduction Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 02:44:03 "},"blog/HTML-Library/":{"url":"blog/HTML-Library/","title":"HTML 基础","keywords":"","body":"这里存放一些关于HTML的资料 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 10:04:18 "},"blog/HTML-Library/HTML-Study.html":{"url":"blog/HTML-Library/HTML-Study.html","title":"HTML常备基础","keywords":"","body":"HTML基础 src 和 href 的区别？ href 时指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。 src 时指向外部的资源位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也是如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。 cookies、session、sessionStorage、localStorage cookies : 存储于浏览器，可以设置 cookies 的到期时间，若不设置，关闭浏览器窗口，cookie就会消失。 session ： 存储于服务端，session 存储特定用户会话所需的属性和配置信息。 cookie 和 session 区别： cookies 数据存放在客户的浏览器上，session 数据存放在服务器上 cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session ession 如果在生效期访内量过大，会占用服务器性能 session中保存的是对象，cookie中保存的是字符串 sessionStorage ：仅在当前浏览器窗口关闭之前有效 localStorage ：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据 不同 ：sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-25 10:33:18 "},"blog/CSS-Library/":{"url":"blog/CSS-Library/","title":"CSS 速查","keywords":"","body":"这里可以给你的页面加一点活力 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 14:39:54 "},"blog/CSS-Library/layout.html":{"url":"blog/CSS-Library/layout.html","title":"CSS布局","keywords":"","body":"别再问我布局了喔 盒子垂直水平居中 提供四中解决方法 ： 1、定位 盒子宽高已知， position: absolute; left: 50%; top: 50%; margin-left:-自身一半宽度; margin-top: -自身一半高度; 2、table-cell布局 父级 display: table-cell; vertical-align: middle; 子级 margin: 0 auto; 3、定位 + transform ; 适用于 子盒子 宽高不定时； （这里是本人常用方法） position: relative / absolute; /*top和left偏移各为50%*/ top: 50%; left: 50%; /*translate(-50%,-50%) 偏移自身的宽和高的-50%*/ transform: translate(-50%, -50%); 注意这里启动了3D硬件加速哦 会增加耗电量的 （至于何是3D加速 请看浏览器进程与线程篇） 4、flex 布局 父级： /*flex 布局*/ display: flex; /*实现垂直居中*/ align-items: center; /*实现水平居中*/ justify-content: center; 高度已知，三栏布局，左右宽度300，中间自适应 效果如下 ： 1、float html 部分，center 放后面 css 部分 .container { height: 200px; } .left { float: left; width: 300px; height: 100%; background: red; } .right { float: right; width: 300px; height: 100%; background: yellow; } .center { background: skyblue; height: 100%; margin: 0 300px; } 2、position 定位 HTML 不变 css .container { position: relative; height: 200px; } .container>div { position: absolute; } .left { left: 0; width: 300px; height: 100%; background: red; } .right { right: 0; width: 300px; height: 100%; background: yellow; } .center { background: skyblue; height: 100%; left: 300px; right: 300px; } 3、flex 布局 HTML center 放置中间 css .container { display: flex; height: 200px; } .left { width: 300px; height: 100%; background: red; } .right { width: 300px; height: 100%; background: yellow; } .center { background: skyblue; height: 100%; flex: 1; } 4、table 布局 html 同 3 ccs .container { display: table; width: 100%;//注意，要加上 width: 100%; center 不设置 width 将会自适应 height: 200px; } .container>div{ display: table-cell; } .left { width: 300px; height: 100%; background: red; } .right { width: 300px; height: 100%; background: yellow; } .center { background: skyblue; height: 100%; } 5、Grid 布局 网格布局 Grid第一个专门为解决布局问题而创建的CSS模块 (设置容器类型,然后设置列宽和行高，Grid 详细了解 html 同 3 css .container { display: grid; grid-template-columns:300px auto 300px; width: 100%; height: 200px; } .left { height: 100%; background: red; } .right { height: 100%; background: yellow; } .center { background: skyblue; height: 100%; } 方案的一些缺点 方案1 2 ：float和position方案的有点是兼容性好,因为都是比较老的解决方案了, 缺点是float之后需要清除浮动造成的影响, 定位的话就是绝对定位之后脱离文档流了,你要注意用position:relative包裹一下 方案3 ： flex IE 8以下不兼容 方案4 ：语义化不佳 方案 5：并没有做到大部分浏览器兼容，不过以后grid是一个趋势 如何实现一个最大的正方形 利用 padding -bottom 原理：对元素的margin设置百分数时，百分数是相对于父元素的width计算，不管是margin-top/margin-bottom还是margin-left/margin-right。当然，padding的原理也是一样的。 .section{ width: 100%; padding-bottom: 100%; background-color: cyan; } 画一个直角三角形 利用 border 代码 ： div { width: 0; border: 200px solid transparent; border-bottom-color: cyan; border-right-color: cyan; } 画一个书签 .bookmark { width: 0; height: 200px; border-left: 50px solid #ccc; border-right: 50px solid #ccc; border-bottom: 40px solid transparent; } 如何用css实现瀑布流布局 利用 column 属性 column-count：指定列数 column-gap: 设置列之间的间距 .waterfall-width-column { column-count: 3; column-gap: 10px; .image-box { img { display: block; width: 100%; } } } Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 17:48:00 "},"blog/CSS-Library/我都知道的CSS.html":{"url":"blog/CSS-Library/我都知道的CSS.html","title":"我都知道的CSS","keywords":"","body":" 我可能是个标题党，因为我是个连菜鸡都不屑于啄的油菜籽。恩，大家好,我是前端油菜籽。 我本来想凑齐20个我知道的CSS，看着体面些，后来发现我都知道的CSS是因为我知道的太少了。 1、css盒模型 box-sizing 属性：border-box、content-box context-box：W3C的标准盒子模型(默认)、 盒子实际内容（content）的width/height=我们设置的width/height;盒子总宽度/高度=width/height+padding+border+margin。 border-box：IE传统盒子模型。 盒子的（content）宽度+内边距padding+边框border宽度=我们设置的width(height也是如此)，盒子总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin。 2、常见一些的兼容性问题 2.1 Chrome 中文界面下设置小于 12px 的文本显示 解： p{ font-size:12px; -webkit-transform:scale(0.5);//0.5是缩放比例，即设置显示6px } 2.2 超链接访问过后hover样式就失效 原因：因为被点击访问过的超链接样式也就不再具有hover和active了 解：改变CSS属性的排列顺序为：L-V-H-A a:link {} a:visited {} a:hover {} a:active {} 3、伪类和伪元素 常见伪类，如2.2中a标签的:link、:visited等常见伪元素，::after ::before 简单理解：目视区别 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 从字面理解意思 伪类就是假的类，伪元素就是假的元素。 定义区别： CSS 伪类用于向某些选择器添加特殊的效果。CSS 伪元素用于将特殊的效果添加到某些选择器。 伪类存在的意义是为了通过选择器，格式化DOM树以外的信息以及不能被常规CSS选择器获取到的信息 当然，上面的你看起来可能有点难以理解，这说的啥玩意儿啊，那么下面我们从功能上来理解 伪类的两种功能： 格式化DOM树以外的信息。比如： \\ 标签的:link、:visited 等。这些信息不存在于DOM树中。 不能被常规CSS选择器获取到的信息。比如：要获取第一个子元素，我们无法用常规的CSS选择器获取，但可以通过 :first-child 来获取到。 伪元素：可以创建一些文档语言无法创建的虚拟元素 我们可以在其中添加内容或样式。如常见的利用伪元素清除浮动。 总结，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。 4、当margin与padding的值设置为百分比时相对于谁？ 当margin和padding的值设置为百分比时，是指相对于最近的块级父元素width（非总宽度）的相应百分比的值，即使是margin-top、margin-bottom、padding-top、padding-bottom，设置为百分比时也是以最近块级父元素的width（非总宽度）为基准，而非height。 5、 li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？ 行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔。 解： 制造无空白条件，将\\代码全部写在一排； 利用浮动，浮动li中float：left； 在ul中用font-size：0（谷歌不支持）； 设置 ul{letter-spacing: -4px;};li{letter-spacing: normal;} 6、行内元素和块级元素的具体区别？行内元素的 padding 和 margin 是否可设置？ 块级元素( block )： 老大哥，总是独占一行；宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制； 内联元素(inline)特性： 患难兄弟，和相邻的内联元素在同一行;宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变即只有padding和margin的left和right是可以设置的。 7、rgba() 和 opacity 的透明效果有何区别？ 都能实现透明效果，opacity（一人得道鸡犬升天的意味）作用于元素，以及元素内的所有的元素的透明度，rgba()**只作用于元素的颜色或其背景色。** 8、CSS引入的方式使用Link和@import有什么区别？ 两者都为外部引用CSS的方式，但是存在一定的区别 link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS； link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载； link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 9、\"nth-child\"和\"nth-of-type\"的区别 简单的字面理解：“nth-of-type” type即指定类型， 而“nth-child”，只要是其子代即可 “nth-child”选择的是父元素的子元素，这个子元素并没有指定确切类型，同时满足两个条件时方能有效果：其一是子元素，其二是子元素刚好处在那个位置；“nth-of-type”选择的是某父元素的子元素，而且这个子元素是指定类型。 10、CSS选择器的匹配规则？为什么？ CSS选择器的匹配是从右向左进行的 因为考虑性能问题，所以需要考虑的是如何在选择器不匹配时提升效率。从右向左匹配正是为了达成这一目的的，通过这一策略能够使得CSS选择器在不匹配的时候效率更高。 11、line-height: 2; 和 line-height: 200%; 有什么区别? 父元素设置line-height:2会直接继承给子元素，子元素根据自己的font-size再去计算子元素自己的line-height。即父、子元素各自计算。 父元素设置line-height:200%是计算好了line-height值，然后把这个计算值给子元素继承，子元素继承拿到的就是最终的值了。此时子元素设置font-size就对其line-height无影响了。 即父元素计算，子拿来即用 举个栗子：比如父元素设置属性：font- size：14px;line-height: 2 , child设置font-size:26px; 那么父元素：line-height = 14px 2 = 28px， **子元素：line-height = 26px 2 = 52px。** 父元素设置属性：font-size:14px;line-height:200%,child设置font-size:26px; 那么父元素：line-height = 14px 200% = 28px，*子元素：line-height = 父元素的line-height = 28px 12、Canvas 和 SVG 有什么区别？ Canvas 通过 JavaScript 来绘制 2D 图形。 是逐像素进行渲染的。 位置一旦发生改变，将重新进行绘制 依赖分辨率 能够以 .png 或 .jpg 格式保存结果图像 弱的文本渲染能力 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 使用XML描述的2D图形的语言 SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。 不依赖分辨率 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用 说了那么多，俺觉得还是丢链接实在Canvas 和 SVG 有什么区别？ 13、啥是聚焦环，正确的解决方案？ 当使用按钮或链接标签获得焦点时，会得到一个可见的外边框，这就是聚焦环。它的种类依赖于根据浏览器提供商，但通常会显示一个蓝色的外边框包围在元素的周围，以表明它当前获得了焦点。 在过去，许多人指定outline: 0;来去除元素上的聚焦环。然而，由于不可见会对键盘用户访问性造成困扰。当不指定时，它会形成一个不吸引人的蓝色环显示在元素周围。 然而:focus-visible可以很好的解决这个问题，他是非常年轻的一个伪类，目前仅Chrome浏览器标准支持，关于这个伪类具体可看这里CSS :focus-visible伪类让我感动哭了 14、关于重绘与重排，以及一些优化问题？ 感觉俺要写不动了，这里看到有篇文章讲的不错 浏览器重绘(repaint)重排(reflow)与优化[浏览器机制] 15、说说@media属性的四种类型 print，指用于打印机的不透明介质。 scren，指屏幕设备 tv，电视类型媒体 all，所有媒体设备 16、transition和animation的区别 这两货大部分属性相同，都是随时间改变元素的属性值，主要区别在于transitionn 需要触发一个事件才能改变属性，而animation不需要，animation和gif动态图差不多，立即播放。 同时可以这样理解，transition是从：hover延伸出来的，不管是动态设置的还是非动态设置的过渡效果，只要过渡效果指定的属性值发生了变化就会触发过渡效果。animation是从flash延伸出来的，使用关键帧的概念， 17、CSS 通用兄弟选择器和相邻兄弟选择器区别？ 通用兄弟选择器 ~ 会选择指定元素所有的兄弟元素 举个栗子：下例会选择 元素所有的 兄弟元素 div ~ p { background-color:cyan; } 相邻兄弟选择器 +会选择指定元素相邻的兄弟元素 举个栗子：下例会选择 元素后的 元素 div + p { background-color:cyan; } 整那么多都没用，简单字面理解就完事，通用兄弟选择就是一条船上，生死患难，大家都得是兄弟，相邻兄弟就是邻居比亲兄弟还亲。 随着油菜籽人生阅历的不断增长，所知道CSS也 应该 会越来越多，所以本文我都知道的CSS或将得到后续更新。 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 10:10:30 "},"blog/CSS-Library/CSS-study.html":{"url":"blog/CSS-Library/CSS-study.html","title":"CSS问答","keywords":"","body":"CSS 技巧 css实现文本溢出显示 ... 单行文本 : overflow: hidden; text-overflow:ellipsis; white-space: nowrap; 当然还需要加宽度width属来兼容部分浏览。 多行文本（如3行） display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; 1、-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性： 2、display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。 3、-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 postion fixed和transform的冲突 我们知道这里 fixed 默认参照对像是可视窗口，如果transformEle (父元素)使用了transform，而fixedEle (子元素)使用了position: fixed，那么position: fixed不会有固定在可视窗口上，实际结果相当于相对transformEle元素定位，就是fixed相对的不是可视窗口，而是transformELe, 产生这样的原因主要是因为transform和position: fixed使用了不同的坐标系统 已知父级盒子的宽高，子级img宽高未知，想让img铺满父级盒子且图片不能变形 利用 CSS 的object-fit 属性 关于object-fit 详细 div { width: 100px; height: 100px; } img { object-fit: cover; width: 100%; height: 100%; } Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-01 15:19:11 "},"blog/Javascript-Library/":{"url":"blog/Javascript-Library/","title":"Javascript 文档库","keywords":"","body":"这儿是关于JavaScript的一些基础和进阶 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 10:13:55 "},"blog/Javascript-Library/聊聊原型和原型链.html":{"url":"blog/Javascript-Library/聊聊原型和原型链.html","title":"聊聊原型和原型链","keywords":"","body":"原型和原型链 从构造函数创建对象说起 function Person() { } var person = new Person(); person.name = 'Vimalakirti'; console.log(person.name) // Vimalakirti 在上面例子中，我们已经知道的是Person为一个构造函数，person为实例对象，我们通过new创建。 prototype 我们知道每个函数都有一个prototype属性, 如我们经常用： function Person() { } //注意！！！ prototype是函数才会有的属性 Person.prototype.name = 'Liu'; var person1 = new Person(); var person2 = new Person(); console.log(person1.name) // Liu console.log(person2.name) // Liu 那么我们有一个疑问，这个Person函数prototype属性指向了谁？ 函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 何为原型：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。 于是自此我们可以一下图表示构造函数和实例原型间的关系 _proto_ 每一个JS对象（除了null）都有的一个属性，叫proto,这个属性指向的是该对象的原型，我们可以以下代码证明 function Person(){ } var person=new Person console.log(person._proto_===Person.prototype)//true 于是我们的关系图得到更新 俗话说的好，送礼都有来有往，我们已经知道实例和构造函数都可以指向实例原型，那么实例原型是否能够指回这两者呢。 prototype和proto的区别 proto是所有对象（包括函数对象）都有的一个属性（当然只是逻辑上有这么个概念），当我们说“原型链”的时候，就是指对象通过这个属性互相连接而形成的链状结构。原型链也就是继承链。 prototype是只有函数（准确地说是构造函数）才有的一个属性，例如对于对于某个函数Fun。它的意义在于，当你用var obj = new Fun() 得到一个对象obj时，这个obj的原型就是F.prototype。即(new Fun()).proto === Fun.prototype constructor 这里我们引出constructor，因为构造函数可以生成多个实例，所以实例原型指回实例这条路行不通，然而实例原型指回构造函数是存在的： 即每个原型都有一个 constructor 属性指向关联的构造函数。 关系图再次得到更新： 我们通过下列代码实践下： function Person() { } var person = new Person(); //person为实例对象，Person为构造函数 console.log(person.__proto__ == Person.prototype) // true console.log(Person.prototype.constructor == Person) // true console.log(Object.getPrototypeOf(person) === Person.prototype) // true 原型与实例的关系 我们经常看到 function Person() { } Person.prototype.name = 'father'; var person = new Person(); person.name = 'son'; console.log(person.name) // son delete person.name; console.log(person.name) // father 可以看到我们删除了 person 的 name 属性，再次读取 person.name 时，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person._proto_ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 father 。 当然，这是幸运的情况，假如 person 的原型上没有找到呢？原型的原型又是个啥？ 原型的原型 我们从前面的学习已经知道，原型也是一个对象，即原型就可以用 new Object() 这种原始的方法创建，综上，我们整理下，实例的 _proto_ 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链 我们再次产生疑问，Object.prototype 的原型又是谁呢？ 我们在控制台输入 console.log(Object.prototype.__proto__ === null) // true 对的，为null 所以属性的查找查到 Object.prototype 下一级好没找到时 ，返回null 最终，我们得到了一张关系图 而我们常说的原型链就是图中蓝色的这条关系线 参考文章： 三张图搞懂JavaScript的原型对象与原型链 JavaScript深入之从原型到原型链 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-26 11:46:48 "},"blog/Javascript-Library/new.html":{"url":"blog/Javascript-Library/new.html","title":"new 实现原理","keywords":"","body":"实现一个 new 操作符 首先，我们来看一道面试题 function Person(name) { this.name = name return name; } let p = new Person('Viamlakirti'); console.log(p)//? 请问输出什么？ 'Viamlakirti' ?你是不是想当然的回答，那么我告诉你错了，代码丢到控制台 what ? 这是咋回事 要想明白咋回事？我们就得了解一下 new 的过程中到底发生了什么？ MDN 上是这样解释的 ： new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作： 创建一个空的简单JavaScript对象（即{}）； 链接该对象（即设置该对象的构造函数）到另一个对象 ； 将步骤1新创建的对象作为this的上下文 ； 如果该函数没有返回对象，则返回this。 好吧，还是不怎么明白，我们来个例子来理解 new 的作用，理解了作用，就能知道其原理 function Person(name) { this.name = name } Person.prototype.sayName = function () { console.log(this.name) } const p = new Person('liu') console.log(t.name) // 'liu' t.sayName() // 'liu' 从这个例子我们可以得出： new 出来的实例可以访问到 Person 这个构造函数中的属性 new 出来的实例可以访问到 Person 这个构造函数中原型链中的属性 ，即通过 new 操作符，实例与构造函数通过原型链连接了起来 从面试题到面试题 ： 我们回到开始的面试题，当我们进行 new 操作时，，return 了一个非对象，函数返回了构造函数实例化后的对象。让我们再看下面几个例子 function Person1(name) { this.name = name; // 没有返回值 } function Person2(name) { this.name = name; return name; // 返回非对象 } function Person3(name) { this.name = name; return { a: 1 }; // 返回对象 } function Person4(name) { this.name = name; return null; // 返回null } var p1 = new Person1(\"aa\"); var p2 = new Person2(\"bb\"); var p3 = new Person3(\"cc\"); var p4 = new Person4(\"dd\"); console.log(p1); // Person1 {name: \"aa\"} console.log(p2); // Person2 {name: \"bb\"} console.log(p3); // {a: 1} console.log(p4); // Person4 {name: \"dd\"} 通过以上例子： 构造函数如果返回原始值，那么这个返回值毫无意义 构造函数如果返回值为对象，那么这个返回值会被正常使用 好了，我们回顾下 new 操作符的几个作用 ： new 操作符会返回一个对象，所以我们需要在内部创建一个对象 这个对象，也就是构造函数中的 this，可以访问到挂载在 this 上的任意属性(改变 this 指向) 这个对象可以访问到构造函数原型上的属性，所以需要将对象与构造函数链接起来 返回原始值需要忽略，返回对象需要正常处理 下面我们动手自己实现一个 new function create(Con, ...args) { let obj = {} Object.setPrototypeOf(obj, Con.prototype) let result = Con.apply(obj, args) return result instanceof Object ? result : obj } 各步骤详解： 首先函数接受不定量的参数，第一个参数为构造函数，接下来的参数被构造函数使用; 然后内部创建一个空对象 obj; 因为 obj 对象需要访问到构造函数原型链上的属性，所以我们通过 setPrototypeOf 将两者联系起来。这段代码等同于 obj.proto = Con.prototype; 将 obj 绑定到构造函数上，并且传入剩余的参数; 判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 obj，这样就实现了忽略构造函数返回的原始值 文档参考 : 聊聊 new 操作符 理解 new 运算符 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-26 02:58:53 "},"blog/Javascript-Library/js存储和垃圾回收.html":{"url":"blog/Javascript-Library/js存储和垃圾回收.html","title":"js存储和垃圾回收","keywords":"","body":"js 存储和垃圾回收 js 存储数据方式 我们都知道 js 的数据类型有以下7种 ： Number,String,Symbol,null,undefined,Boolean和Object 除了 Object 是复杂类型，其他皆为简单类型，他们的不同之处在于内存存储的方式。 内存分为堆内存(heap) 和 栈内存(stack),，js引擎在解析代码时： 遇到简单类型的声明，就在栈内存里开辟一个空间，将简单类型的值放进去； 如果遇到复杂类型，就在栈内存，堆内存分别开辟一个空间。将自身的值放进堆内存，并将存在堆内存的这块空间的地址，放进栈内存。 堆内存 中存的是我们声明的object类型的数据，栈内存 中存的是 基本数据类型 以及 函数执行时的运行空间。 看看这几题 我们在了解了 js 的存储方式后，来看看以下几题 : 1、 var a = 1 var b = a b = 2 console.log(a) 2、 var a ={name:'vimalakirti'} b = a b.name = 'vmkt' console.log(a) 3、 var a ={name:'vimalakirti'} b = a b.name = {'name':'vmkt'} console.log(a.name) 4、 var a ={name:'vimalakirti'} b = a b= null console.log(a.name) 答案揭晓：按题目顺序分别为 2 、'vmkt' 、'vimalakirti' 、'vimalakirti' 前两题应该很好理解，如果你还是感到困惑的话，那么可能确实需要加强一下 js 方面的基础知识。 第 3 题 ： 复杂类型拷贝的时候为，如果为赋值操作，那么拷贝的是引用，即第 3 题第三行 b.name = {'name':'vmkt'}, b.name 指向了另一堆内存中的值，并不会改变 a 的值。 第 4 题 ： 同第 3 题，将 b 重新赋值给了 null ，而我们知道null为 js 中的简单类型，存储在栈内存，也就是说 b 的引用不存在了，栈内存存储的是新赋的值，不再是引用。 结论 ：复杂类型的赋值操作，如果引用改变（地址改变），则 b 改变不影响原来 a 的值。 什么是垃圾回收？ 程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存。所谓的内存泄漏简单来说是不再用到的内存，没有及时释放。为了更好避免内存泄漏。 由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。 ——《JavaScript权威指南（第四版）》 即是说JavaScript垃圾回收是： 找出不再使用的变量，然后释放掉其占用的内存 垃圾回收机制 垃圾回收有两种方法：标记清除、引用计数。 标记清除 标记清除是 js 中最常用的垃圾回收方式 ，当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。 引用计数 引用计数核心原理是: 判断一个对象是否要被回收就是要看是否还有引用指向它,如果是\"零引用\",即引用次数为0 ，那么就回收。 但这种回收算法有一个严重缺陷—————循环引用 function func() { let obj1 = {}; let obj2 = {}; obj1.a = obj2; // obj1 引用 obj2 obj2.a = obj1; // obj2 引用 obj1 } 当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。 常见内存泄漏 忘记声明的局部变量 function a(){ b=2 } b 没被声明,会变成一个全局变量,在页面关闭之前不会被释放.使用严格模式可以避免. 闭包带来的内存泄漏 function a(){ let b=2 return function(){ console.log(b) } } b 在闭包中引用，不会被回收 定时器中的内存泄漏 var someResource = getData(); setInterval(function() { var node = document.getElementById('Node'); if(node) { node.innerHTML = JSON.stringify(someResource)); } }, 1000); 这样的代码很常见，如果 id 为 Node 的元素从 DOM 中移除，该定时器仍会存在，同时，因为回调函数中包含对 someResource 的引用，定时器外面的 someResource 也不会被释放。 移除 DOM 节点时候忘记移除暂存的值 有时候出于优化性能的目的,我们会用一个变量暂存 节点,接下来使用的时候就不用再从 DOM 中去获取.但是在移除 DOM 节点的时候却忘记了解除暂存的变量对 DOM 节点的引用,也会造成内存泄漏 var element = { image: document.getElementById('image'), button: document.getElementById('button') }; document.body.removeChild(document.getElementById('image')); // 如果element没有被回收,这里移除了 image 节点也是没用的,image 节点依然留存在内存中. 与此类似情景还有: DOM 节点绑定了事件, 但是在移除的时候没有解除事件绑定,那么仅仅移除 DOM节点也是没用的 垃圾回收 JavaScript中的垃圾回收和内存泄漏 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-01 12:43:34 "},"blog/Javascript-Library/我都知道的js.html":{"url":"blog/Javascript-Library/我都知道的js.html","title":"我都知道的js","keywords":"","body":"我都知道的JS 1、for...in和for...of的区别？ for in更适合遍历对象，不要使用for in遍历数组。 for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。 for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name 2、介绍模块化发展历程 1. IIFE 自执行函数编写代码，单独作用域，避免变量冲突 2. AMD requireJS编写代码，特点依赖必须声明好 3.CMD seaJS编写代码，支持动态引入依赖文件 4.commonJS nodeJS自带模块化 5. ES6 支持import引入另一个js 3、cookie 和 token 都存放在 header 中，为什么不会劫持 token？ cookie：登陆后后端生成一个sessionid放在cookie中返回给客户端，并且服务端一直记录着这个sessionid，客户端以后每次请求都会带上这个sessionid，服务端通过这个sessionid来验证身份之类的操作。所以别人拿到了cookie拿到了sessionid后，就可以完全替代你。 token：登陆后后端不返回一个token给客户端，客户端将这个token存储起来，然后每次客户端请求都需要开发者手动将token放在header中带过去，服务端每次只需要对这个token进行验证就能使用token中的信息来进行下一步操作了。 形象化理解： cookie 举例：服务员看你的身份证，给你一个编号，以后，进行任何操作，都出示编号后服务员去看查你是谁。 token 举例：直接给服务员看自己身份证。 xss：用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。 csrf：跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。csrf并不能够拿到用户的任何信息，它只是欺骗用户浏览器，让其以用户的名义进行操作。 上面的两种攻击方式，如果被xss攻击了，不管是token还是cookie，都能被拿到，所以对于xss攻击来说，cookie和token没有什么区别。但是对于csrf来说就有区别了。 上面的csrf攻击为例： cookie：用户点击了链接，cookie未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作。 token：用户点击链接，由于浏览器不会自动带上token，所以即使发了请求，后端的token验证不会通过，所以不会进行扣款操作。 总结：CSRF攻击的原因是浏览器会自动带上cookie，而浏览器不会自动带上token 4、下列代码打印什么？ var b = 10; (function b(){ b = 20; console.log(b); })(); 直接打印b fn 我的理解是，先不看函数自执行，直接fn b() 首先函数声明比变量要高，其次b = 20 没有var 获取其他，说明是window最外层定义的变量。 js作用域中，先找最近的 那就是b fn ，直接打印了，如果 b = 20 有var 那就是打印20 5、（京东）下面代码中 a 在什么情况下会打印 1？ var a = ?; if(a == 1 && a == 2 && a == 3){ console.log(1); } 利用数组 改写toString方法 var a=[1,2,3] a.toString=a.shift if(a == 1 && a == 2 && a == 3){ console.log(1); } 利用valueOf ==隐式转换会调用本类型toString或valueOf方法. var a={ i:1 valueOf(){ return a.i++ } } if(a == 1 && a == 2 && a == 3){ console.log(1); } 利用toString 上栗valueOf改为toString即可 6、数组的splice和slice的用法和区别 1. splice(start,deleteCount,item1,item2.....); items 为要添加的元素 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组 改变原数组，数组长度发生变化 2. slice(start，end) 返回值为截取出来的元素的集合 原始数组不会发生变化 3.其他一些数组方法扩展 push / pop 在数组末尾增/删元素； unshift / shift 在数组首部增/删元素； concat 把一个（或多个）数组和（或）值与原数组拼接，返回拼接后的数组 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔 reverse() 颠倒数组中元素的顺序 7、（百度）实现 (5).add(3).minus(2) 功能。 Number.prototype.add=function(n){ return this+n } Number.prototype.minus=function(n){ return this-n } console.log((5).add(3).minus(2)) 8、Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？ Object.defineProperty无法监控到数组下标 的变化，导致通过数组下标添加元素，不能实时响应； Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。 Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性 9、Vue 的父组件和子组件生命周期钩子执行顺序是什么 ？ 加载渲染过程 父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted 子组件更新过程 父beforeUpdate->子beforeUpdate->子updated->父updated 父组件更新过程 父beforeUpdate->父updated 销毁过程 父beforeDestroy->子beforeDestroy->子destroyed->父destroyed 总结：从外到内，再从内到外 10、 JS String 和 new String的区别 当通过new 调用 String()时,返回的是一个object 当通过字面量或者直接调用String(),返回的是一个字符串 实现add函数,让add(a)(b)和add(a,b)两种调用结果相同 function add(a,b) { if(!b){ return function (x){ return a+x } } return a+b } 如何让：a == 1 && a == 2 && a == 3 const a = { value:[3,2,1], valueOf:function(){ //隐式转换调用 valueOf ，pop()删除数组最后一个元素,改变原数组，返回被删除的元素. return this.value.pop() } } Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-02 13:57:06 "},"blog/VUE-Library/":{"url":"blog/VUE-Library/","title":"Vue 文档库","keywords":"","body":"这里存放了关于VUE的学习笔记 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 10:12:12 "},"blog/VUE-Library/vuex.html":{"url":"blog/VUE-Library/vuex.html","title":"vuex","keywords":"","body":"vuex知识总结 ​ Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 10:12:33 "},"blog/VUE-Library/vue响应原理.html":{"url":"blog/VUE-Library/vue响应原理.html","title":"vue响应原理","keywords":"","body":"vue 响应原理 Vue.js的响应式原理依赖于Object.defineProperty，Vue通过设定对象属性的 setter/getter 方法来监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。 initData 方法 在 Vue 的初始化的时候，其 _init() 方法会调用执行 initState(vm) 方法。initState 方法主要是对 props、methods、data、computed 和 wathcer 等属性做了初始化操作。 Vue 通过【观察者模式】实现了一套响应式系统。观察者模式（也叫发布/订阅模式）会将观察者和被观察的对象严格分离开，当被观察对象的状态发生变化时，所有依赖于它的观察者都将得到通知并自动刷新。举个栗子，用户界面可以作为一个观察者，业务数据是被观察者，用户界面观察业务数据的变化，当数据发生变化时，用户界面就会自动更新。 数据劫持 — Observe // 给对象的属性添加 getter 和 setter，用于依赖收集和发布更新 export class Observer { value: any; dep: Dep; vmCount: number; constructor (value: any) { this.value = value // 实例化 Dep 对象 this.dep = new Dep() this.vmCount = 0 // 把自身实例添加到数据对象 value 的 __ob__ 属性上 def(value, '__ob__', this) // value 是否为数组的不同调用 if (Array.isArray(value)) { const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) } else { this.walk(value) } } // 取出所有属性遍历 walk (obj: Object) { const keys = Object.keys(obj) for (let i = 0; i ) { for (let i = 0, l = items.length; i getter 方法完成的工作就是依赖收集 —— dep.depend() setter 方法完成的工作就是发布更新 —— dep.notify() 将数据data变成可观察的 我们可以大概总结一些整个响应式系统的流程，也是我们常说的 观察者模式：第一步当然是通过 observer 进行数据劫持，然后在需要订阅的地方（如：模版编译），添加观察者（watcher），并立刻通过取值操作触发指定属性的 getter 方法，从而将观察者添加进 Dep （利用了闭包的特性，进行依赖收集），然后在 Setter 触发的时候，进行 notify，通知给所有观察者并进行相应的 update。 我们可以这么理解 观察者模式：Dep 就好比是掘金，掘金有很多作者（相当于 data 的很多属性）。我们自然都是充当订阅者（watcher）角色，在掘金（Dep）这里关注了我们感兴趣的作者，比如：xxx，告诉它xxx更新了就提醒我去看。那么每当江三疯有新内容时，我们都会收到类似这样的提醒：xxx发布了【2019 前端进阶之路 ***】，然后我们就可以去看了。 但是，每个 watcher 可以订阅很多作者，每个作者也都会更新文章。那么没有关注xxx的用户会收到提醒吗 ？不会，只给已经订阅了的用户发送提醒，而且只有江三疯更新了才提醒，你订阅的是xxx，可是站长更新了需要提醒你吗？当然不需要。这，也就是闭包需要做的事情。 总结 总结起来，Vue 的响应原理主要包括以下几个步骤 具体步骤： 第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化 第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:在自身实例化时往属性订阅器(dep)里面添加自己自身必须有一个 update()方法待属性变动 dep.notice()通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。 第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。 参考文档 大白话Vue源码 Vue 响应式原理 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 00:20:28 "},"blog/VUE-Library/vue 123.html":{"url":"blog/VUE-Library/vue 123.html","title":"vue123","keywords":"","body":"vue 123 生命周期钩子函数 beforeCreate（初始化界面前） created（初始化界面后） beforeMount（渲染dom前） mounted（渲染dom后） beforeUpdate（更新数据前） updated（更新数据后） beforeDestroy（卸载组件前） destroyed（卸载组件后） 钩子函数，其实和回调是一个概念，当系统执行到某处时，检查是否有hook，有则回调。说的更直白一点，每个组件都有属性，方法和事件。所有的生命周期都归于事件，在某个时刻自动执行。生老病死 我们首先需要创建一个实例，也就是在 new Vue ( ) 的对象过程当中，首先执行了init（init是vue组件里面默认去执行的），在init的过程当中首先调用了beforeCreate，然后在injections（注射）和reactivity（反应性）的时候，它会再去调用created。所以在init的时候，事件已经调用了，我们在beforeCreate的时候千万不要去修改data里面赋值的数据，最早也要放在created里面去做（添加一些行为）。 created完成之后，它会去判断instance（实例）里面是否含有“el”option（选项），如果没有的话，它会调用vm.$mount(el)这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有“template”这个选项，如果有的话，它会把template解析成一个render function ，即template编译的过程，结果是解析成了render函数 render函数是发生在beforeMount和mounted之间的，这也从侧面说明了，在beforeMount的时候，$el还只是我们在HTML里面写的节点，然后到mounted的时候，它就把渲染出来的内容挂载到了DOM节点上。这中间的过程其实是执行了render function的内容。 beforeMount在有了render function的时候才会执行，当执行完render function之后，就会调用mounted这个钩子，在mounted挂载完毕之后，这个实例就算是走完流程了。 另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。 组件通信 父子组件通信 兄弟组件通信 跨多层级组件通信 任意组件 父子 父组件通过 props 传递数据给子组件，子组件通过 emit 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。 单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props， 而是必须通过发送事件的方式告知父组件修改数据。父组件通过v-on监听并接收参数 当然我们还可以通过访问 $parent 或者 $children 对象来访问组件实例中的方法和数据。 v-model 因为 v-model 默认会解析成名为 value 的 prop 和名为 input 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。 兄弟 eventBus 初始化： // event-bus.js import Vue from 'vue' export const EventBus = new Vue() 兄弟组件通过EventBus.$emit分发和EventBus.$on接收 $children / $parent 对于这种情况可以通过查找父组件中的子组件实现，也就是 this.$parent.$children，在 $children中可以通过组件 name 查询到需要的组件实例，然后进行通信。 mixin 和 mixins 区别 mixin 用于全局混入，以全局混入封装好的 ajax 或者一些工具函数等等。 mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。 需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读 文档 computed 和 watch 区别 computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。 所以一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。 v-show 与 v-if 区别 v-show 无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。display:none属性，所以总的来说 v-show 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。，v-show是控制有没有display：none这个样式来控制显隐。 v-if 条件渲染，切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。 vue中组件的data为什么是一个函数 组件是可复用的vue实例，一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的data数据都应该是相互隔离，互不影响的。 组件中的data 写成函数，数据以函数返回值定义，这样每复用一次组件，就能够获得一份独立的 data 拷贝，互不影响。 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-05 23:01:50 "},"blog/LeetCode-Library/":{"url":"blog/LeetCode-Library/","title":"力扣 LeetCode","keywords":"","body":"刷题很辛苦的，写刷题文章更辛苦啊 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 10:20:12 "},"blog/LeetCode-Library/121-买卖股票最佳时机.html":{"url":"blog/LeetCode-Library/121-买卖股票最佳时机.html","title":"121-买卖股票最佳时机","keywords":"","body":" 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例2 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解法 var maxProfit = function(prices) { let max=0 for(let i=0;imax){ max=target } } } return max }; 思路 ： n+i 天>n 天的股票值，双重 for 循环，记录每一次的新高 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-26 11:41:05 "},"blog/LeetCode-Library/122-买卖股票最佳时机2.html":{"url":"blog/LeetCode-Library/122-买卖股票最佳时机2.html","title":"122-买卖股票最佳时机","keywords":"","body":"给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例1： 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解 ： var maxProfit = function(prices) { let max=0 for(let i=0;i 解析 ： 只要有利可图——即后一天比前一天高，就卖出 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-27 12:27:05 "},"blog/LeetCode-Library/123-验证回文串.html":{"url":"blog/LeetCode-Library/123-验证回文串.html","title":"123-验证回文串","keywords":"","body":" 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: \"A man, a plan, a canal: Panama\" 输出: true 示例 2: 输入: \"race a car\" 输出: false 解 1： var isPalindrome = function(s) { //将s中数字，非大小写字符替换掉，统一小写 s=s.replace(/[^0-9a-zA-Z]/g,'').toLocaleLowerCase() //先字符串转换数组，反转，再转回字符串 let reverse=s.split('').reverse().join('') return s===reverse }; 解 2 ： var isPalindrome = function(s) { s=s.replace(/[^0-9a-zA-Z]/g,'').toLocaleLowerCase() //双指针，判断回文，循环一半即可，如为奇数（5/7），可忽略中间那个数，不影响。全等于才返回 true for(let i=0;i Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-28 11:19:11 "},"blog/LeetCode-Library/136-只出现一次的数字.html":{"url":"blog/LeetCode-Library/136-只出现一次的数字.html","title":"136-只出现一次的数字","keywords":"","body":"给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 解 ： var singleNumber = function(nums) { //排序 nums.sort() for(let i=0;i Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-29 13:21:49 "},"blog/LeetCode-Library/156-最小栈.html":{"url":"blog/LeetCode-Library/156-最小栈.html","title":"156-最小栈","keywords":"","body":"设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) -- 将元素 x 推入栈中。 pop() -- 删除栈顶的元素。 top() -- 获取栈顶元素。 getMin() -- 检索栈中的最小元素。 示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --> 返回 -3. minStack.pop(); minStack.top(); --> 返回 0. minStack.getMin(); --> 返回 -2. 解 ： var MinStack = function() { this.stack=[] this.min=null }; /** * @param {number} x * @return {void} */ MinStack.prototype.push = function(x) { this.stack.push(x) if(this.min===null){ this.min=x }else{ this.min=Math.min(this.min,x) } }; /** * @return {void} */ MinStack.prototype.pop = function() { this.stack.pop() this.min=this.stack.length?this.stack.reduce((min,num)=>Math.min(min,num),Infinity):null }; /** * @return {number} */ MinStack.prototype.top = function() { if(!this.stack.length){ return null } return this.stack[this.stack.length-1] }; /** * @return {number} */ MinStack.prototype.getMin = function() { return this.min }; Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-30 10:32:22 "},"blog/LeetCode-Library/167-两数之和.html":{"url":"blog/LeetCode-Library/167-两数之和.html","title":"167-两数之和","keywords":"","body":"给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 解 ： 双指针 var twoSum = function(numbers, target) { for(let i=0;i map var twoSum = function(numbers, target) { let map=new Map for(let i=0;i map 详细 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 13:24:44 "},"blog/LeetCode-Library/168-Excel列表名称.html":{"url":"blog/LeetCode-Library/168-Excel列表名称.html","title":"168-Excel列表名称","keywords":"","body":"给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如 : 1 -> A 2 -> B 3 -> C ... 26 -> Z 27 -> AA 28 -> AB ... 示例 1: 输入: 1 输出: \"A\" 示例 2: 输入: 28 输出: \"AB\" 示例 3: 输入: 701 输出: \"ZY\" 解 ： var convertToTitle = function (n) { let res = '' while (n != 0) { n-- //接收一个 Unicode 值，返回一个字符串 res = String.fromCharCode(n % 26 + 65) + res n = parseInt(n / 26) } return res } 解说 ： 从给出条件可以看出 26 一个循环，在 ASCII 中 A 对照为65，当循环一轮，如27，那么新的一轮位于初始第一个，所以n-- 才能对上 A ，即0=》65=》A。 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-02 11:45:29 "},"blog/LeetCode-Library/169-求众数.html":{"url":"blog/LeetCode-Library/169-求众数.html","title":"169-求众数","keywords":"","body":"原题 ： 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 解 ： var majorityElement = function (nums) { //Map：以键值对的形式保存，任何值（原始值或对象）都能够作为一个键或一个值 let map = new Map() //num 如果只有一个，那么众数就直接返回 if (nums.length === 1) { return nums[0] } for (let i = 0; i nums.length / 2) return nums[i] } else { //没有的话就存入，并设为初始数量1 map.set(nums[i], 1) } } }; Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-02 13:23:27 "},"blog/LeetCode-Library/171-Excel表列序号.html":{"url":"blog/LeetCode-Library/171-Excel表列序号.html","title":"171-Excel表列序号","keywords":"","body":"原题 ： 给定一个Excel表格中的列名称，返回其相应的列序号。 例如， A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ... 示例 1: 输入: \"A\" 输出: 1 示例 2: 输入: \"AB\" 输出: 28 示例 3: 输入: \"ZY\" 输出: 701 解 ： var titleToNumber = function (s) { let res = 0 let base = 1 //每次*26的n次方，初始为1即为26的0次方 for (let num of [...s].reverse()) { //如 AB 即为1*26^1+2*26^0=28,以此类推 res += (num.charCodeAt() - 64) * base base *= 26 } return res }; Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-02 12:24:40 "},"blog/LeetCode-Library/172-阶乘后的零.html":{"url":"blog/LeetCode-Library/172-阶乘后的零.html","title":"172-阶乘后的零","keywords":"","body":"原题 给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 输入: 3 输出: 0 解释: 3! = 6, 尾数中没有零。 示例 2: 输入: 5 输出: 1 解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 解 ： 找阶乘后的零，很简单的，我们发现，当 n 为 5 的因数时，就会有5*2 、10*1 ,阶乘后末尾就会有零，所以我们列出一些情况。 n 零的个数 5 1 10 2 15 3 20 4 25 6 30 7 35 8 40 9 45 10 50 12 我们发现，当 n 为5 的倍数时，逐渐增长，但当 n 为25 ，50 时出现了意外，稍加思索就会发现，当 n 为 25 的倍数时，阶乘时会有 25*4 出现两个零 var trailingZeroes = function (n) { let sum = 0 while (n >= 5) { n = Math.floor(n / 5)//只要还为5的倍数，就继续相加 sum += n } return sum }; Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 13:08:53 "},"blog/LeetCode-Library/189-旋转数组.html":{"url":"blog/LeetCode-Library/189-旋转数组.html","title":"189-旋转数组","keywords":"","body":"原题 ： 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入: [-1,-100,3,99] 和 k = 2 输出: [3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 原地 算法。 解 ： 从题意很容易可以看出，所谓的旋转数组，就是把数组后 K 位数放到数组的前面 所以，我们很容易想到下面的解法： var rotate = function (nums, k) { let arr = [] for (let i = 0; i unshift() 将一个或多个元素添加到数组的开头，并返回数组的长度，pop() 删除数组最后一个元素，并返回改元素的值，改变原数组的长度。 方法 2 ： 利用 splice() 方法 var rotate = function (nums, k) { if (k) { //如k=3，7-3=4，从第四位开始，删除3个数 nums.unshift(...nums.splice(nums.length - k, k)) } }; Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-04 23:29:31 "},"blog/LeetCode-Library/190-颠倒二进制位.html":{"url":"blog/LeetCode-Library/190-颠倒二进制位.html","title":"190-颠倒二进制位","keywords":"","body":"原题 ： 颠倒给定的 32 位无符号整数的二进制位。 示例 1： 输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 输入：11111111111111111111111111111101 输出：10111111111111111111111111111111 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 进阶: 如果多次调用这个函数，你将如何优化你的算法？ 解 ： var reverseBits = function (n) { return parseInt(n.toString(2).padStart(32, '0').split('').reverse().join(''), 2) }; parseInt(string,radix) : string为字符串，radix为介于2-36之间的数。使用者告诉这个函数string（比如11）是radix（比如2）进制的，函数将固定返回string以十进制时显示的数（3）。 padStart() : 用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。 split() : 切割字符串为数组 join() :将数组（或类数组）所有元素连接成字符串并返回。 return parseInt(n.toString(2).padStart(32, '0').split('').reverse().join(''), 2) 接下来我们来讲讲思路，先拆分化解，n.toString(2) 将 n 转换为2进制，然后 padStart(32, '0') 将他填充至32位，不够的首位开始补0。 而后就容易理解了，先转数组，然后翻转，再转回字符串，最后利用 parseInt(str,2) 转回为 2 进制。 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-05 11:10:21 "},"blog/LeetCode-Library/191-位1的个数.html":{"url":"blog/LeetCode-Library/191-位1的个数.html","title":"191-位1的个数","keywords":"","body":"原题 ： 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 示例 1： 输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2： 输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3： 输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 解 : var hammingWeight = function (n) { //先转换成 2 进制，替换掉非 1 （即 0）的数 return n.toString(2).replace(/0/g, '').length }; Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-05 11:10:05 "},"blog/LeetCode-Library/202-快乐数.html":{"url":"blog/LeetCode-Library/202-快乐数.html","title":"202-快乐数","keywords":"","body":"原题 编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 输入: 19 输出: true 解释: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 解 ： var isHappy = function (n) { let set = new Set(), sum n += '' while (sum != 1) { sum = 0 for (let i = 0; i set : Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。 如： const set1 = new Set([1, 2, 3, 4, 5]); console.log(set1)//Set(5) {1, 2, 3, 4, 5} Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-06 12:29:50 "},"blog/LeetCode-Library/204-计数质数.html":{"url":"blog/LeetCode-Library/204-计数质数.html","title":"204-计数质数","keywords":"","body":"原题 统计所有小于非负整数 n 的质数的数量。 示例: 输入: 10 输出: 4 解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解 ： var countPrimes = function (n) { if (n { return item != null }) return result.length }; 厄拉多塞解法 : 详情 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-07 12:11:01 "},"blog/LeetCode-Library/205-同构字符串.html":{"url":"blog/LeetCode-Library/205-同构字符串.html","title":"205-同构字符串","keywords":"","body":"原题 给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1: 输入: s = \"egg\", t = \"add\" 输出: true 示例 2: 输入: s = \"foo\", t = \"bar\" 输出: false 示例 3: 输入: s = \"paper\", t = \"title\" 输出: true 说明: 你可以假设 s 和 t 具有相同的长度。 解 ： var isIsomorphic = function (s, t) { for (let i = 0; i 题解 ： indexOf()遍历返回第一个符合条件的值的索引，存在则返回，不存在返回-1，因此判断两字符串返回下标是否一致即可。 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 14:16:32 "},"blog/LeetCode-Library/206-反转链表 ×.html":{"url":"blog/LeetCode-Library/206-反转链表 ×.html","title":"206-反转链表 ×","keywords":"","body":"原题 反转一个单链表。 示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL 进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解 ： var reverseList = function (head) { let newHead = null while (head) { // 单独取出下一个节点 let next = head.next // 将头节点连接到新头节点后面 head.next = newHead newHead = head // 向后移动头节点 head = next } return newHead }; Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-09 14:25:10 "},"blog/LeetCode-Library/217-存在重复元素.html":{"url":"blog/LeetCode-Library/217-存在重复元素.html","title":"217-存在重复元素","keywords":"","body":"原题 给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 输入: [1,2,3,1] 输出: true 示例 2: 输入: [1,2,3,4] 输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 解 ： 利用 indexOf() var containsDuplicate = function (nums) { for (let i = 0; i 利用 indexOf()和lastIndexOf var containsDuplicate = function (nums) { for (let i = 0; i 利用 set() var containsDuplicate = function (nums) { let len = new Set(nums).size return nums.length === len ? false : true }; 利用Map var containsDuplicate = function (nums) { let map = new Map() for (let i = 0; i Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-09 15:15:12 "},"blog/Other-Library/":{"url":"blog/Other-Library/","title":"其他文档库","keywords":"","body":"这里存放一些奇思妙想，如Git，HTTP... Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 22:16:23 "},"blog/Other-Library/Git Document Library/":{"url":"blog/Other-Library/Git Document Library/","title":"Git","keywords":"","body":"这里存放关于Git 的一些资料和学习问题 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 22:18:41 "},"blog/Other-Library/Git Document Library/gitbook.html":{"url":"blog/Other-Library/Git Document Library/gitbook.html","title":"gitbook serve问题","keywords":"","body":"使用gitbook serve/build 遇到的错误 使用gitbook serve/build 时，遇到 Vimalakirti>gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 18 plugins are installed info: 14 explicitly listed info: loading plugin \"prism\"... OK info: loading plugin \"copy-code-button\"... OK info: loading plugin \"search-pro\"... OK info: loading plugin \"expandable-chapters\"... OK info: loading plugin \"splitter\"... OK info: loading plugin \"github-buttons\"... OK info: loading plugin \"donate\"... OK info: loading plugin \"tbfed-pagefooter\"... OK info: loading plugin \"baidu-tongji\"... OK info: loading plugin \"anchor-navigation-ex\"... OK info: loading plugin \"livereload\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-comscore\"... OK info: loading plugin \"theme-default\"... OK info: found 7 pages info: found 8 asset files warn: \"options\" property is deprecated, use config.get(key) instead warn: \"options.generator\" property is deprecated, use \"output.name\" instead init! Error: ENOENT: no such file or directory, stat 'C:\\Users\\liujian1\\Desktop\\Vimalakirti\\_book\\gitbook\\gitbook-plugin-theme-comscore\\test.css' 于是乎，开启Google 大法，终于在 gitbook 的 issue 找到解决办法 按照issue的解决方法具体如下： 首先进入到 C:\\Users\\Administrator.gitbook\\versions\\3.2.3\\lib\\output\\website 然后找到文件copyPluginAssets.js，这里我选用vscode打开 找到112行 将confirm: true 修改为 false 保存然后重新 gitbook serve/build OK，成功 Starting server ... Serving book on http://localhost:4000 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 21:52:56 "},"blog/Other-Library/HTTP.html":{"url":"blog/Other-Library/HTTP.html","title":"从 URL 输入到页面展现","keywords":"","body":"从 URL 输入到页面展现发生的事 看到这个问题，你是不是马上自信的答出： 从 URL 输入到页面展现经过以下过程： 在浏览器输入 URL； 浏览器查找域名对应的 IP 地址； 浏览器根据 IP 地址与服务器建立联系； 浏览器与服务器通信：浏览器请求，服务器处理请求并呈现页面。 这是个非常容易遇到的面试题，但要让面试官对我们的回答满意，还需更深入的了解。 经常的，我们打开一个网站 https://juejin.im/user/5c87e597e51d455cd96a1053/collections 上面这一连串的字符，称为 URL ，就是我们常说的网址。而浏览器正是靠一个个 URL 来查找资源的具体位置的。 1、URL 组成 就以上例网站为例， 1.1、协议部分 https 它是浏览器和 www 万维网之间的沟通方式，它会告诉浏览器在网络世界中找到资源的正确位置。 常见协议有： http（最常见的网络传输协议）、https（进行加密的网络传输协议）、file（本地文件夹协议）、ftp、telnet 等。 1.2、域名部分 juejin.im 当然，我们更多的看到的是 xxx.com,xxx.cn 这种类型。 域名是人们为了方便记忆，所使用的语义化的方式登录网站，但我们必须要知道的是，每一个域名背后都有其对应的 IP 地址。 如我们都知道，当前电脑的 IP 是 127.0.0.1 ，也就是代表自己。 1.3、资源路径部分 /user/5c87e597e51d455cd96a1053/collections 域名后的这一串乱七八糟，就是资源路径部分啰 2、DNS 在我们了解了域名和 IP 之后，二者又是怎样联系到一起的呢。这里就引出了 DNS ， DNS ——用来记录域名和 IP 地址相互映射的信息。 DNS 作用：可以让人们免于记住那些繁琐的数串； 全国 DNS 信息可以在网上查找到，各省都有对应分配的 IP 网段； 大型企业都有自己的 DNS 服务器，专门用来存储域名和 IP 的映射关系； 如谷歌的 DNS 服务器地址 8.8.8.8 ；国内知名 DNS 服务器地址 114.114.114.114 。 3、具体流程分析 3.1、浏览器输入 URL 当然是用你的键盘输啊 3.2、浏览器查找域名对应的 IP 地址 因为浏览器本身并不能识别 URL 是什么，因此从我们输入 URL 开始，浏览器就要进行域名解析来找到对应 IP——DNS 解析是浏览器的实际寻址方式： 先查找浏览器缓存，浏览器会缓存 DNS 记录一段时间，如浏览器会缓存我们近期逛过的网站， （如果没有则往下） ； 查找系统缓存——从 C 盘的 hosts 文件查找是否有存储的 DNS 信息，查找是否有目标域名和对应的 IP 地址 （如果没有则往下）； 查找路由器缓存 （如果没有则往下）； 从网络服务商（比如电信）的 DNS 缓存信息中查找（如果没有则往下）； 以上都未找到，就会向根域名服务器查找目标 URL 对应的 IP，根域名服务器会向下级服务器转达请求，层层下发，直到找到对应的 IP 为止。 3.3、浏览器根据 IP 地址与服务器建立联系 上一阶段中，浏览器通过 IP 寻址找到了对应的服务器，浏览器就将用户发起的 http 请求发送给服务器。服务器开始处理用户请求 3.4、浏览器与服务器通信 经过上一步骤，服务器返回了 html 字符串给浏览器，此时，浏览器将会对其进行解析、渲染并最终绘制网页： 1、加载 ： 浏览器对 html 页面进行加载，加载顺序自上而下。 览器在加载的过程中，同时进行解析、渲染处理 在这个过程中，遇到 link 标签、image 标签、script 标签时，浏览器会再次向服务器发送请求以获取相应的 css 文件、图片资源、js 文件，并执行 js 代码，同步进行加载、解析。 2、 解析、渲染 ： 解析的过程，其实就是生成 dom 树 dom 树是由 dom 元素及属性节点组成，并且加上 css 解析的样式对象和 js解析后的动作实现； 渲染：就是将 dom 树进行可视化表示。 3、生成网页 浏览器通过渲染，将 dom 树可视化，得到渲染树； 构建渲染树使页面以正确的顺序绘制出来，浏览器遵循一定的渲染规则，实现网站页面的绘制，并最终完成页面的展示。 以上就是从 URL 输入到页面展示的全部过程了 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-24 17:18:42 "},"blog/Other-Library/skill/":{"url":"blog/Other-Library/skill/","title":"能提高幸福感的一些技巧","keywords":"","body":"一些能提高编码幸福感的小技巧 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-30 11:44:32 "},"blog/Other-Library/skill/skill.html":{"url":"blog/Other-Library/skill/skill.html","title":"skill","keywords":"","body":"树状结构变一维数组 flatten(arr) { return [].concat(...arr.map(item=>[].concat(item,...flatten(item.subitems)))) } ellipsis 指定宽度 vue移动端禁止页面整体下拉 #app { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 0; width: 100%; height: 100%; background: #7d8188; overflow: hidden; -webkit-overflow-scrolling: touch; } 利用 a 标签解析 URL function parseURL(url) { var a = document.createElement('a'); a.href = url; return { host: a.hostname, port: a.port, query: a.search, params: (function(){ var ret = {}, seg = a.search.replace(/^\\?/,'').split('&'), len = seg.length, i = 0, s; for (;i Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-30 17:22:18 "},"blog/Other-Library/markdown.html":{"url":"blog/Other-Library/markdown.html","title":"Markdown 奇淫技巧","keywords":"","body":"Markdown 奇淫技巧 Markdown 是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。经常的，我们使用 Markdown 来写笔记，常用的语法我们就不说了，网上一搜一大把。自己写笔记，博客啥的时候多用了几遍也就会了。 我们今天要聊的是关于 Markdown 的一些“奇淫技巧”——那些我们不是经常使用，但用起来又能够给我们写的笔记，博客增添不少色彩的技巧。 图片大小 很多时候，我们插入的一些图片尺寸不大时，他看起来会有点别扭 直接使用 img 标签就行了 使用 Emoji 为了让我们的文字显得更为的生动有趣，GitHub 实现了对标准 Markdown 标记之外的扩展。 实例代码 ： 我要是，有技术。:angry: 实例效果 ： 我要是，有技术。:angry: 更多可用 Emoji 代码可参见 https://www.webpagefx.com/tools/emoji-cheat-sheet/。 行首缩进 直接在 Markdown 里用空格和 Tab 键缩进在渲染后会被忽略，这时候我们可以考虑 HTML 转义字符，&ensp;代表半角空格，&emsp;代表全角空格。 &emsp;&emsp;我要是，有技术 效果 :   我要是，有技术 任务列表 我们经常使用有序列表和无序列表，但是当我们遇到要列出一些清单的场景时，我们可以考虑使用任务列表。 示例代码 ： **今日安排 :** - [x] 吃早点 - [ ] 上班 - [x] 摸鱼 - [ ] coding - [x] 睡觉 效果 ： 今日安排 : [x] 吃早点 [ ] 上班 [x] 摸鱼 [ ] coding [x] 睡觉 目录索引 之前使用 Markdown 一直不知道这个用法，后来是在掘金上看到 jsliang 的文章,有着目录索引，点击即可调转到对应的章节，这无疑给阅读者带来一定方便。 于是乎想着自己也实现一下，发现方法其实很简单。 目录生成，只要文章是按照markdown语法写作的。在需要生成目录的地方写 [TOC]，如我们需要在下面生成目录 示例代码 **效果** [TOC] ## 设置组块折叠 **实现方法 ：** ```text 请点击我 我是被隐藏的文字 看不同平台，不一定能正常换行、使用 MarkDown 语法。 请点击我 我是被隐藏的文字 发现用 Typora 写的时候有一点兼容问题，但是 vscode （要装对应插件）显示正常，放到 github 也是正常的。 显示红绿对比的 diff 啥是红绿对比的 diff ，看下面 ： - 研表究明，汉字的顺序并不一定能影响阅读 + 研表究明，汉字的序顺并不定一能影阅响读 如何在 Markdown 实现呢，很简单 ​```diff - 减号后是原来的字符。 + 加号后是改后的字符。 ​ ``` Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-27 12:32:44 "},"blog/essay/":{"url":"blog/essay/","title":"随笔杂谈","keywords":"","body":"也无多趣事，恐年老，不计心中矣 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-31 10:45:38 "},"blog/essay/one.html":{"url":"blog/essay/one.html","title":"one","keywords":"","body":"想起之前在掘金发的沸点 我们大多数人不论过程和付出，看结果。 时间往复，永不回头。 王小波说：“生活就是个缓慢受锤的过程”。这是今天看到的一句话，想起年轻的时候，喜欢读冯唐，王小波。 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-08 14:23:34 "}}