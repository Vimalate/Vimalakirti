{"./":{"url":"./","title":"首页","keywords":"","body":"Introduction Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 02:44:03 "},"blog/我都知道的CSS.html":{"url":"blog/我都知道的CSS.html","title":"我都知道的CSS","keywords":"","body":" 我可能是个标题党，因为我是个连菜鸡都不屑于啄的油菜籽。恩，大家好,我是前端油菜籽。 我本来想凑齐20个我知道的CSS，看着体面些，后来发现我都知道的CSS是因为我知道的太少了。 1、css盒模型 box-sizing 属性：border-box、content-box context-box：W3C的标准盒子模型(默认)、 盒子实际内容（content）的width/height=我们设置的width/height;盒子总宽度/高度=width/height+padding+border+margin。 border-box：IE传统盒子模型。 盒子的（content）宽度+内边距padding+边框border宽度=我们设置的width(height也是如此)，盒子总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin。 2、常见一些的兼容性问题 2.1 Chrome 中文界面下设置小于 12px 的文本显示 解： p{ font-size:12px; -webkit-transform:scale(0.5);//0.5是缩放比例，即设置显示6px } 2.2 超链接访问过后hover样式就失效 原因：因为被点击访问过的超链接样式也就不再具有hover和active了 解：改变CSS属性的排列顺序为：L-V-H-A a:link {} a:visited {} a:hover {} a:active {} 3、伪类和伪元素 常见伪类，如2.2中a标签的:link、:visited等常见伪元素，::after ::before 简单理解：目视区别 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 从字面理解意思 伪类就是假的类，伪元素就是假的元素。 定义区别： CSS 伪类用于向某些选择器添加特殊的效果。CSS 伪元素用于将特殊的效果添加到某些选择器。 伪类存在的意义是为了通过选择器，格式化DOM树以外的信息以及不能被常规CSS选择器获取到的信息 当然，上面的你看起来可能有点难以理解，这说的啥玩意儿啊，那么下面我们从功能上来理解 伪类的两种功能： 格式化DOM树以外的信息。比如： \\ 标签的:link、:visited 等。这些信息不存在于DOM树中。 不能被常规CSS选择器获取到的信息。比如：要获取第一个子元素，我们无法用常规的CSS选择器获取，但可以通过 :first-child 来获取到。 伪元素：可以创建一些文档语言无法创建的虚拟元素 我们可以在其中添加内容或样式。如常见的利用伪元素清除浮动。 总结，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。 4、当margin与padding的值设置为百分比时相对于谁？ 当margin和padding的值设置为百分比时，是指相对于最近的块级父元素width（非总宽度）的相应百分比的值，即使是margin-top、margin-bottom、padding-top、padding-bottom，设置为百分比时也是以最近块级父元素的width（非总宽度）为基准，而非height。 5、 li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？ 行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔。 解： 制造无空白条件，将\\代码全部写在一排； 利用浮动，浮动li中float：left； 在ul中用font-size：0（谷歌不支持）； 设置 ul{letter-spacing: -4px;};li{letter-spacing: normal;} 6、行内元素和块级元素的具体区别？行内元素的 padding 和 margin 是否可设置？ 块级元素( block )： 老大哥，总是独占一行；宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制； 内联元素(inline)特性： 患难兄弟，和相邻的内联元素在同一行;宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变即只有padding和margin的left和right是可以设置的。 7、rgba() 和 opacity 的透明效果有何区别？ 都能实现透明效果，opacity（一人得道鸡犬升天的意味）作用于元素，以及元素内的所有的元素的透明度，rgba()**只作用于元素的颜色或其背景色。** 8、CSS引入的方式使用Link和@import有什么区别？ 两者都为外部引用CSS的方式，但是存在一定的区别 link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS； link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载； link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 9、\"nth-child\"和\"nth-of-type\"的区别 简单的字面理解：“nth-of-type” type即指定类型， 而“nth-child”，只要是其子代即可 “nth-child”选择的是父元素的子元素，这个子元素并没有指定确切类型，同时满足两个条件时方能有效果：其一是子元素，其二是子元素刚好处在那个位置；“nth-of-type”选择的是某父元素的子元素，而且这个子元素是指定类型。 10、CSS选择器的匹配规则？为什么？ CSS选择器的匹配是从右向左进行的 因为考虑性能问题，所以需要考虑的是如何在选择器不匹配时提升效率。从右向左匹配正是为了达成这一目的的，通过这一策略能够使得CSS选择器在不匹配的时候效率更高。 11、line-height: 2; 和 line-height: 200%; 有什么区别? 父元素设置line-height:2会直接继承给子元素，子元素根据自己的font-size再去计算子元素自己的line-height。即父、子元素各自计算。 父元素设置line-height:200%是计算好了line-height值，然后把这个计算值给子元素继承，子元素继承拿到的就是最终的值了。此时子元素设置font-size就对其line-height无影响了。 即父元素计算，子拿来即用 举个栗子：比如父元素设置属性：font- size：14px;line-height: 2 , child设置font-size:26px; 那么父元素：line-height = 14px 2 = 28px， **子元素：line-height = 26px 2 = 52px。** 父元素设置属性：font-size:14px;line-height:200%,child设置font-size:26px; 那么父元素：line-height = 14px 200% = 28px，*子元素：line-height = 父元素的line-height = 28px 12、Canvas 和 SVG 有什么区别？ Canvas 通过 JavaScript 来绘制 2D 图形。 是逐像素进行渲染的。 位置一旦发生改变，将重新进行绘制 依赖分辨率 能够以 .png 或 .jpg 格式保存结果图像 弱的文本渲染能力 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 使用XML描述的2D图形的语言 SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。 不依赖分辨率 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用 说了那么多，俺觉得还是丢链接实在Canvas 和 SVG 有什么区别？ 13、啥是聚焦环，正确的解决方案？ 当使用按钮或链接标签获得焦点时，会得到一个可见的外边框，这就是聚焦环。它的种类依赖于根据浏览器提供商，但通常会显示一个蓝色的外边框包围在元素的周围，以表明它当前获得了焦点。 在过去，许多人指定outline: 0;来去除元素上的聚焦环。然而，由于不可见会对键盘用户访问性造成困扰。当不指定时，它会形成一个不吸引人的蓝色环显示在元素周围。 然而:focus-visible可以很好的解决这个问题，他是非常年轻的一个伪类，目前仅Chrome浏览器标准支持，关于这个伪类具体可看这里CSS :focus-visible伪类让我感动哭了 14、关于重绘与重排，以及一些优化问题？ 感觉俺要写不动了，这里看到有篇文章讲的不错 浏览器重绘(repaint)重排(reflow)与优化[浏览器机制] 15、说说@media属性的四种类型 print，指用于打印机的不透明介质。 scren，指屏幕设备 tv，电视类型媒体 all，所有媒体设备 16、transition和animation的区别 这两货大部分属性相同，都是随时间改变元素的属性值，主要区别在于transitionn 需要触发一个事件才能改变属性，而animation不需要，animation和gif动态图差不多，立即播放。 同时可以这样理解，transition是从：hover延伸出来的，不管是动态设置的还是非动态设置的过渡效果，只要过渡效果指定的属性值发生了变化就会触发过渡效果。animation是从flash延伸出来的，使用关键帧的概念， 17、CSS 通用兄弟选择器和相邻兄弟选择器区别？ 通用兄弟选择器 ~ 会选择指定元素所有的兄弟元素 举个栗子：下例会选择 元素所有的 兄弟元素 div ~ p { background-color:cyan; } 相邻兄弟选择器 +会选择指定元素相邻的兄弟元素 举个栗子：下例会选择 元素后的 元素 div + p { background-color:cyan; } 整那么多都没用，简单字面理解就完事，通用兄弟选择就是一条船上，生死患难，大家都得是兄弟，相邻兄弟就是邻居比亲兄弟还亲。 随着油菜籽人生阅历的不断增长，所知道CSS也 应该 会越来越多，所以本文我都知道的CSS或将得到后续更新。 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 04:20:50 "},"blog/聊聊原型和原型链.html":{"url":"blog/聊聊原型和原型链.html","title":"聊聊原型和原型链","keywords":"","body":"Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 00:40:30 "},"blog/我都知道的js.html":{"url":"blog/我都知道的js.html","title":"我都知道的js","keywords":"","body":"我都知道的JS 1、for...in和for...of的区别？ for in更适合遍历对象，不要使用for in遍历数组。 for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。 for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name 2、介绍模块化发展历程 1. IIFE 自执行函数编写代码，单独作用域，避免变量冲突 2. AMD requireJS编写代码，特点依赖必须声明好 3.CMD seaJS编写代码，支持动态引入依赖文件 4.commonJS nodeJS自带模块化 5. ES6 支持import引入另一个js 3、cookie 和 token 都存放在 header 中，为什么不会劫持 token？ cookie：登陆后后端生成一个sessionid放在cookie中返回给客户端，并且服务端一直记录着这个sessionid，客户端以后每次请求都会带上这个sessionid，服务端通过这个sessionid来验证身份之类的操作。所以别人拿到了cookie拿到了sessionid后，就可以完全替代你。 token：登陆后后端不返回一个token给客户端，客户端将这个token存储起来，然后每次客户端请求都需要开发者手动将token放在header中带过去，服务端每次只需要对这个token进行验证就能使用token中的信息来进行下一步操作了。 形象化理解： cookie 举例：服务员看你的身份证，给你一个编号，以后，进行任何操作，都出示编号后服务员去看查你是谁。 token 举例：直接给服务员看自己身份证。 xss：用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。 csrf：跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。csrf并不能够拿到用户的任何信息，它只是欺骗用户浏览器，让其以用户的名义进行操作。 上面的两种攻击方式，如果被xss攻击了，不管是token还是cookie，都能被拿到，所以对于xss攻击来说，cookie和token没有什么区别。但是对于csrf来说就有区别了。 上面的csrf攻击为例： cookie：用户点击了链接，cookie未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作。 token：用户点击链接，由于浏览器不会自动带上token，所以即使发了请求，后端的token验证不会通过，所以不会进行扣款操作。 总结：CSRF攻击的原因是浏览器会自动带上cookie，而浏览器不会自动带上token 4、下列代码打印什么？ var b = 10; (function b(){ b = 20; console.log(b); })(); 直接打印b fn 我的理解是，先不看函数自执行，直接fn b() 首先函数声明比变量要高，其次b = 20 没有var 获取其他，说明是window最外层定义的变量。 js作用域中，先找最近的 那就是b fn ，直接打印了，如果 b = 20 有var 那就是打印20 5、（京东）下面代码中 a 在什么情况下会打印 1？ var a = ?; if(a == 1 && a == 2 && a == 3){ console.log(1); } 利用数组 改写toString方法 var a=[1,2,3] a.toString=a.shift if(a == 1 && a == 2 && a == 3){ console.log(1); } 利用valueOf ==隐式转换会调用本类型toString或valueOf方法. var a={ i:1 valueOf(){ return a.i++ } } if(a == 1 && a == 2 && a == 3){ console.log(1); } 利用toString 上栗valueOf改为toString即可 6、数组的splice和slice的用法和区别 1. splice(start,deleteCount,item1,item2.....); items 为要添加的元素 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组 改变原数组，数组长度发生变化 2. slice(start，end) 返回值为截取出来的元素的集合 原始数组不会发生变化 3.其他一些数组方法扩展 push / pop 在数组末尾增/删元素； unshift / shift 在数组首部增/删元素； concat 把一个（或多个）数组和（或）值与原数组拼接，返回拼接后的数组 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔 reverse() 颠倒数组中元素的顺序 7、（百度）实现 (5).add(3).minus(2) 功能。 Number.prototype.add=function(n){ return this+n } Number.prototype.minus=function(n){ return this-n } console.log((5).add(3).minus(2)) 8、Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？ Object.defineProperty无法监控到数组下标 的变化，导致通过数组下标添加元素，不能实时响应； Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。 Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性 9、Vue 的父组件和子组件生命周期钩子执行顺序是什么 ？ 加载渲染过程 父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted 子组件更新过程 父beforeUpdate->子beforeUpdate->子updated->父updated 父组件更新过程 父beforeUpdate->父updated 销毁过程 父beforeDestroy->子beforeDestroy->子destroyed->父destroyed 总结：从外到内，再从内到外 10、 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 01:04:52 "},"blog/vuex.html":{"url":"blog/vuex.html","title":"vuex","keywords":"","body":"vuex知识总结 ​ Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-23 00:41:10 "},"blog/vue 123.html":{"url":"blog/vue 123.html","title":"vue123","keywords":"","body":"vue 123 生命周期钩子函数 beforeCreate（初始化界面前） created（初始化界面后） beforeMount（渲染dom前） mounted（渲染dom后） beforeUpdate（更新数据前） updated（更新数据后） beforeDestroy（卸载组件前） destroyed（卸载组件后） 钩子函数，其实和回调是一个概念，当系统执行到某处时，检查是否有hook，有则回调。说的更直白一点，每个组件都有属性，方法和事件。所有的生命周期都归于事件，在某个时刻自动执行。生老病死 我们首先需要创建一个实例，也就是在 new Vue ( ) 的对象过程当中，首先执行了init（init是vue组件里面默认去执行的），在init的过程当中首先调用了beforeCreate，然后在injections（注射）和reactivity（反应性）的时候，它会再去调用created。所以在init的时候，事件已经调用了，我们在beforeCreate的时候千万不要去修改data里面赋值的数据，最早也要放在created里面去做（添加一些行为）。 created完成之后，它会去判断instance（实例）里面是否含有“el”option（选项），如果没有的话，它会调用vm.$mount(el)这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有“template”这个选项，如果有的话，它会把template解析成一个render function ，即template编译的过程，结果是解析成了render函数 render函数是发生在beforeMount和mounted之间的，这也从侧面说明了，在beforeMount的时候，$el还只是我们在HTML里面写的节点，然后到mounted的时候，它就把渲染出来的内容挂载到了DOM节点上。这中间的过程其实是执行了render function的内容。 beforeMount在有了render function的时候才会执行，当执行完render function之后，就会调用mounted这个钩子，在mounted挂载完毕之后，这个实例就算是走完流程了。 另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。 组件通信 父子组件通信 兄弟组件通信 跨多层级组件通信 任意组件 父子 父组件通过 props 传递数据给子组件，子组件通过 emit 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。 单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props， 而是必须通过发送事件的方式告知父组件修改数据。父组件通过v-on监听并接收参数 当然我们还可以通过访问 $parent 或者 $children 对象来访问组件实例中的方法和数据。 v-model 因为 v-model 默认会解析成名为 value 的 prop 和名为 input 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。 兄弟 eventBus 初始化： // event-bus.js import Vue from 'vue' export const EventBus = new Vue() 兄弟组件通过EventBus.$emit分发和EventBus.$on接收 $children / $parent 对于这种情况可以通过查找父组件中的子组件实现，也就是 this.$parent.$children，在 $children中可以通过组件 name 查询到需要的组件实例，然后进行通信。 mixin 和 mixins 区别 mixin 用于全局混入，以全局混入封装好的 ajax 或者一些工具函数等等。 mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。 需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读 文档 computed 和 watch 区别 computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。 所以一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。 v-show 与 v-if 区别 v-show 无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。display:none属性，所以总的来说 v-show 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。 v-if 条件渲染，切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 15:55:14 "},"blog/vue响应原理.html":{"url":"blog/vue响应原理.html","title":"vue响应原理","keywords":"","body":"vue 响应原理 Vue.js的响应式原理依赖于Object.defineProperty，Vue通过设定对象属性的 setter/getter 方法来监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。 initData 方法 在 Vue 的初始化的时候，其 _init() 方法会调用执行 initState(vm) 方法。initState 方法主要是对 props、methods、data、computed 和 wathcer 等属性做了初始化操作。 Vue 通过【观察者模式】实现了一套响应式系统。观察者模式（也叫发布/订阅模式）会将观察者和被观察的对象严格分离开，当被观察对象的状态发生变化时，所有依赖于它的观察者都将得到通知并自动刷新。举个栗子，用户界面可以作为一个观察者，业务数据是被观察者，用户界面观察业务数据的变化，当数据发生变化时，用户界面就会自动更新。 数据劫持 — Observe // 给对象的属性添加 getter 和 setter，用于依赖收集和发布更新 export class Observer { value: any; dep: Dep; vmCount: number; constructor (value: any) { this.value = value // 实例化 Dep 对象 this.dep = new Dep() this.vmCount = 0 // 把自身实例添加到数据对象 value 的 __ob__ 属性上 def(value, '__ob__', this) // value 是否为数组的不同调用 if (Array.isArray(value)) { const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) } else { this.walk(value) } } // 取出所有属性遍历 walk (obj: Object) { const keys = Object.keys(obj) for (let i = 0; i ) { for (let i = 0, l = items.length; i getter 方法完成的工作就是依赖收集 —— dep.depend() setter 方法完成的工作就是发布更新 —— dep.notify() 将数据data变成可观察的 我们可以大概总结一些整个响应式系统的流程，也是我们常说的 观察者模式：第一步当然是通过 observer 进行数据劫持，然后在需要订阅的地方（如：模版编译），添加观察者（watcher），并立刻通过取值操作触发指定属性的 getter 方法，从而将观察者添加进 Dep （利用了闭包的特性，进行依赖收集），然后在 Setter 触发的时候，进行 notify，通知给所有观察者并进行相应的 update。 我们可以这么理解 观察者模式：Dep 就好比是掘金，掘金有很多作者（相当于 data 的很多属性）。我们自然都是充当订阅者（watcher）角色，在掘金（Dep）这里关注了我们感兴趣的作者，比如：xxx，告诉它xxx更新了就提醒我去看。那么每当江三疯有新内容时，我们都会收到类似这样的提醒：xxx发布了【2019 前端进阶之路 ***】，然后我们就可以去看了。 但是，每个 watcher 可以订阅很多作者，每个作者也都会更新文章。那么没有关注xxx的用户会收到提醒吗 ？不会，只给已经订阅了的用户发送提醒，而且只有江三疯更新了才提醒，你订阅的是xxx，可是站长更新了需要提醒你吗？当然不需要。这，也就是闭包需要做的事情。 参考文档 大白话Vue源码 Vue 响应式原理 Copyright © vimalakirti.fun 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-07-22 23:37:19 "}}